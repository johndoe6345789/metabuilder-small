# Docker Compose Integration Snippet for Nginx Reverse Proxy
# Phase 8: Email Client Reverse Proxy
#
# Add this service to your main docker-compose.yml file
# Usage:
#   1. Merge this content into deployment/docker/docker-compose.production.yml
#   2. Generate SSL certificates: ./deployment/docker/nginx/generate-dev-certs.sh
#   3. Update server_name directives in nginx.conf with your domains
#   4. Run: docker-compose -f deployment/docker/docker-compose.production.yml up -d

version: '3.8'

services:
  # Nginx Reverse Proxy with SSL/TLS
  nginx:
    build:
      context: ./deployment/docker/nginx
      dockerfile: Dockerfile
    container_name: emailclient-nginx

    # Expose HTTP/HTTPS ports
    ports:
      - "80:80"
      - "443:443"

    # Mount configuration and SSL certificates
    volumes:
      # Read-only nginx configuration
      - ./deployment/docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro

      # SSL certificates (must exist before running)
      - ./deployment/docker/nginx/ssl:/etc/nginx/ssl:ro

      # Cache and logs (persistent)
      - nginx_cache:/var/cache/nginx
      - nginx_logs:/var/log/nginx

    # Service dependencies
    depends_on:
      - email-service
      - emailclient

    # Restart policy
    restart: unless-stopped

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s

    # Network configuration
    networks:
      - emailclient-network

    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M

    # Environment variables (optional)
    environment:
      # Increase buffer for large responses
      NGINX_HOST: localhost
      NGINX_PORT: 80

  # Email Service (Python Flask backend)
  email-service:
    build:
      context: ./deployment/docker/email-service
      dockerfile: Dockerfile
    container_name: emailclient-email-service

    # Internal network only (accessed via Nginx reverse proxy)
    expose:
      - "5000"

    # Environment configuration
    environment:
      FLASK_ENV: production
      FLASK_APP: app.py
      EMAIL_SERVICE_PORT: 5000
      # Add other email-service environment variables here

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

    # Dependencies
    depends_on:
      - postgres

    # Restart policy
    restart: unless-stopped

    # Network
    networks:
      - emailclient-network

    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

  # Email Client Next.js Frontend
  emailclient:
    build:
      context: ./
      dockerfile: ./deployment/docker/Dockerfile.app
      args:
        NODE_ENV: production
    container_name: emailclient-frontend

    # Internal network only (accessed via Nginx reverse proxy)
    expose:
      - "3000"

    # Environment configuration
    environment:
      NODE_ENV: production
      PORT: 3000
      NEXT_PUBLIC_API_URL: https://api.emailclient.local
      # Add other frontend environment variables here

    # Volumes
    volumes:
      - emailclient_cache:/app/.next/cache
      - emailclient_uploads:/app/uploads

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s

    # Dependencies
    depends_on:
      postgres:
        condition: service_healthy

    # Restart policy
    restart: unless-stopped

    # Network
    networks:
      - emailclient-network

    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

# Volumes
volumes:
  nginx_cache:
    driver: local
  nginx_logs:
    driver: local
  emailclient_cache:
    driver: local
  emailclient_uploads:
    driver: local

# Networks
networks:
  emailclient-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.21.0.0/16

# ============================================================================
# USAGE NOTES
# ============================================================================
#
# 1. GENERATE SSL CERTIFICATES (Required before first run)
#    ./deployment/docker/nginx/generate-dev-certs.sh
#
#    This creates:
#    - deployment/docker/nginx/ssl/cert.pem
#    - deployment/docker/nginx/ssl/key.pem
#    - deployment/docker/nginx/ssl/dhparam.pem
#
# 2. UPDATE NGINX CONFIGURATION
#    Edit deployment/docker/nginx/nginx.conf and update:
#    - server_name directives with your actual domains
#    - upstream server addresses if using non-standard hostnames
#    - rate limits if needed
#
# 3. BUILD AND RUN
#    docker-compose -f deployment/docker/docker-compose.production.yml up -d
#
# 4. VERIFY SERVICES
#    # Check all services are healthy
#    docker-compose -f deployment/docker/docker-compose.production.yml ps
#
#    # Test reverse proxy
#    curl -k https://localhost/health
#    curl -k https://localhost/api/v1/sync
#
# 5. MONITORING
#    # View nginx logs
#    docker logs -f emailclient-nginx
#
#    # Check rate limiting
#    docker exec emailclient-nginx tail -f /var/log/nginx/access.log | grep "limiting"
#
# 6. PRODUCTION DEPLOYMENT
#    - Generate Let's Encrypt certificates (see SSL_SETUP.md)
#    - Update server_name with real domains
#    - Configure DNS to point to your server
#    - Set NEXT_PUBLIC_API_URL to real domain
#    - Monitor certificate expiration
#
# ============================================================================
