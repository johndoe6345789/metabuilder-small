#ifndef DBAL_SQL_ADAPTER_HPP
#define DBAL_SQL_ADAPTER_HPP

#include <algorithm>
#include <cctype>
#include <chrono>
#include <cstdlib>
#include <map>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
#include <fstream>
#include <filesystem>

#include "dbal/adapters/adapter.hpp"
#include "dbal/types.hpp"
#include "dbal/errors.hpp"
#include "sql_connection.hpp"
#include "../../runtime/requests_client.hpp"
#include "../schema_loader.hpp"
#include "../sql_template_generator.hpp"
#include "../../config/env_config.hpp"
#include <spdlog/spdlog.h>
#include <nlohmann/json.hpp>

namespace dbal {
namespace adapters {
namespace sql {

struct SqlParam {
    std::string name;
    std::string value;
};

struct SqlRow {
    std::map<std::string, std::string> columns;
};

struct SqlError {
    enum class Code {
        UniqueViolation,
        ForeignKeyViolation,
        NotFound,
        Timeout,
        ConnectionLost,
        Unknown
    };

    Code code;
    std::string message;
};

/**
 * Generic SQL Adapter - works with any entity from YAML schemas
 *
 * Replaces hardcoded entity methods with schema-driven operations
 */
class SqlAdapter : public Adapter {
public:
    explicit SqlAdapter(const SqlConnectionConfig& config, Dialect dialect)
        : pool_(config), dialect_(dialect) {
        loadSchemas();
        createTables();
    }

    ~SqlAdapter() override = default;

    // ===== Generic CRUD Operations =====

    Result<Json> create(const std::string& entityName, const Json& data) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string sql = buildInsertSql(schema, data);
        const auto params = jsonToParams(schema, data);

        try {
            const auto rows = executeQuery(conn, sql, params);
            if (rows.empty()) {
                return Error::internal("SQL insert returned no rows");
            }
            return rowToJson(schema, rows.front());
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<Json> read(const std::string& entityName, const std::string& id) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string sql = buildSelectSql(schema, Json{{"id", id}});
        const std::vector<SqlParam> params = {{"id", id}};

        try {
            const auto rows = executeQuery(conn, sql, params);
            if (rows.empty()) {
                return Error::notFound(entityName + " not found");
            }
            return rowToJson(schema, rows.front());
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<Json> update(const std::string& entityName, const std::string& id, const Json& data) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string sql = buildUpdateSql(schema, id, data);
        const auto params = jsonToParams(schema, data, id);

        try {
            const auto rows = executeQuery(conn, sql, params);
            if (rows.empty()) {
                return Error::notFound(entityName + " not found");
            }
            return rowToJson(schema, rows.front());
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<bool> remove(const std::string& entityName, const std::string& id) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string sql = buildDeleteSql(schema, id);
        const std::vector<SqlParam> params = {{"id", id}};

        try {
            const int affected = executeNonQuery(conn, sql, params);
            if (affected == 0) {
                return Error::notFound(entityName + " not found");
            }
            return Result<bool>(true);
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<ListResult<Json>> list(const std::string& entityName, const ListOptions& options) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const int limit = options.limit > 0 ? options.limit : 50;
        const int offset = options.page > 1 ? (options.page - 1) * limit : 0;

        // Build filter clause
        std::string whereClause;
        std::vector<SqlParam> params;
        int paramIndex = 1;

        // Apply tenantId filter if present
        auto tenantFilter = options.filter.find("tenantId");
        if (tenantFilter != options.filter.end()) {
            whereClause = " WHERE tenantId = " + placeholder(paramIndex++);
            params.push_back({"tenantId", tenantFilter->second});
        }

        // Build SQL
        const std::string tableName = toLowerSnakeCase(schema.name);
        const std::string fieldList = buildFieldList(schema);
        const std::string sql = "SELECT " + fieldList +
                                " FROM " + tableName + whereClause +
                                " ORDER BY createdAt DESC LIMIT " + placeholder(paramIndex++) +
                                " OFFSET " + placeholder(paramIndex++);
        params.push_back({"limit", std::to_string(limit)});
        params.push_back({"offset", std::to_string(offset)});

        try {
            const auto rows = executeQuery(conn, sql, params);
            std::vector<Json> items;
            items.reserve(rows.size());
            for (const auto& row : rows) {
                items.push_back(rowToJson(schema, row));
            }

            ListResult<Json> result;
            result.items = items;
            result.total = static_cast<int>(items.size());
            result.page = options.page;
            result.limit = limit;
            return Result<ListResult<Json>>(result);
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    // ===== Bulk Operations =====

    Result<int> createMany(const std::string& entityName, const std::vector<Json>& records) override {
        if (records.empty()) {
            return Result<int>(0);
        }

        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        int inserted = 0;
        for (const auto& record : records) {
            const std::string sql = buildInsertSql(schema, record);
            const auto params = jsonToParams(schema, record);
            try {
                executeNonQuery(conn, sql, params);
                inserted++;
            } catch (const SqlError& err) {
                // Continue on error
            }
        }

        return Result<int>(inserted);
    }

    Result<int> updateMany(const std::string& entityName, const Json& filter, const Json& data) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        // Build UPDATE with WHERE clause
        const std::string tableName = toLowerSnakeCase(schema.name);
        std::string sql = "UPDATE " + tableName + " SET ";

        std::vector<SqlParam> params;
        int paramIndex = 1;

        // Build SET clause
        std::vector<std::string> setFragments;
        for (const auto& field : schema.fields) {
            if (data.contains(field.name)) {
                setFragments.push_back(field.name + " = " + placeholder(paramIndex++));
                params.push_back({field.name, jsonValueToString(data[field.name])});
            }
        }

        if (setFragments.empty()) {
            return Error::validationError("No update fields supplied");
        }

        sql += joinFragments(setFragments, ", ");

        // Build WHERE clause
        std::vector<std::string> whereFragments;
        for (const auto& [key, value] : filter.items()) {
            whereFragments.push_back(key + " = " + placeholder(paramIndex++));
            params.push_back({key, jsonValueToString(value)});
        }

        if (!whereFragments.empty()) {
            sql += " WHERE " + joinFragments(whereFragments, " AND ");
        }

        try {
            const int affected = executeNonQuery(conn, sql, params);
            return Result<int>(affected);
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<int> deleteMany(const std::string& entityName, const Json& filter) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string tableName = toLowerSnakeCase(schema.name);
        std::string sql = "DELETE FROM " + tableName;

        std::vector<SqlParam> params;
        int paramIndex = 1;

        // Build WHERE clause
        std::vector<std::string> whereFragments;
        for (const auto& [key, value] : filter.items()) {
            whereFragments.push_back(key + " = " + placeholder(paramIndex++));
            params.push_back({key, jsonValueToString(value)});
        }

        if (!whereFragments.empty()) {
            sql += " WHERE " + joinFragments(whereFragments, " AND ");
        }

        try {
            const int affected = executeNonQuery(conn, sql, params);
            return Result<int>(affected);
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    // ===== Query Operations =====

    Result<Json> findFirst(const std::string& entityName, const Json& filter) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        const auto& schema = *schemaResult;

        auto conn = pool_.acquire();
        if (!conn) {
            return Error::internal("Unable to acquire SQL connection");
        }
        ConnectionGuard guard(pool_, conn);

        const std::string tableName = toLowerSnakeCase(schema.name);
        const std::string fieldList = buildFieldList(schema);
        std::string sql = "SELECT " + fieldList + " FROM " + tableName;

        std::vector<SqlParam> params;
        int paramIndex = 1;

        // Build WHERE clause
        std::vector<std::string> whereFragments;
        for (const auto& [key, value] : filter.items()) {
            whereFragments.push_back(key + " = " + placeholder(paramIndex++));
            params.push_back({key, jsonValueToString(value)});
        }

        if (!whereFragments.empty()) {
            sql += " WHERE " + joinFragments(whereFragments, " AND ");
        }

        sql += " LIMIT 1";

        try {
            const auto rows = executeQuery(conn, sql, params);
            if (rows.empty()) {
                return Error::notFound(entityName + " not found");
            }
            return rowToJson(schema, rows.front());
        } catch (const SqlError& err) {
            return mapSqlError(err);
        }
    }

    Result<Json> findByField(const std::string& entityName, const std::string& field, const Json& value) override {
        Json filter;
        filter[field] = value;
        return findFirst(entityName, filter);
    }

    Result<Json> upsert(const std::string& entityName, const std::string& uniqueField,
                       const Json& uniqueValue, const Json& createData, const Json& updateData) override {
        // Try to find existing record
        auto existingResult = findByField(entityName, uniqueField, uniqueValue);

        if (existingResult.hasValue()) {
            // Record exists, update it
            const auto& existing = existingResult.value();
            std::string id = existing.at("id");
            return update(entityName, id, updateData);
        } else {
            // Record doesn't exist, create it
            return create(entityName, createData);
        }
    }

    // ===== Metadata =====

    Result<std::vector<std::string>> getAvailableEntities() override {
        std::vector<std::string> entities;
        entities.reserve(schemas_.size());
        for (const auto& [name, _] : schemas_) {
            entities.push_back(name);
        }
        return Result<std::vector<std::string>>(entities);
    }

    Result<EntitySchema> getEntitySchema(const std::string& entityName) override {
        auto schemaResult = getEntitySchemaInternal(entityName);
        if (!schemaResult) {
            return Error::validationError("Unknown entity: " + entityName);
        }
        return Result<EntitySchema>(*schemaResult);
    }

    void close() override {
        // Connections will tear down automatically via RAII in the pool.
    }

protected:
    struct ConnectionGuard {
        SqlPool& pool;
        SqlConnection* connection;
        ConnectionGuard(SqlPool& pool_, SqlConnection* connection_)
            : pool(pool_), connection(connection_) {}
        ~ConnectionGuard() {
            if (connection) {
                pool.release(connection);
            }
        }
    };

    std::vector<SqlRow> executeQuery(SqlConnection* connection,
                                     const std::string& sql,
                                     const std::vector<SqlParam>& params) {
        return runQuery(connection, sql, params);
    }

    int executeNonQuery(SqlConnection* connection,
                        const std::string& sql,
                        const std::vector<SqlParam>& params) {
        return runNonQuery(connection, sql, params);
    }

    virtual std::vector<SqlRow> runQuery(SqlConnection*,
                                         const std::string&,
                                         const std::vector<SqlParam>&) {
        throw SqlError{SqlError::Code::Unknown, "SQL execution not implemented"};
    }

    virtual int runNonQuery(SqlConnection*,
                            const std::string&,
                            const std::vector<SqlParam>&) {
        throw SqlError{SqlError::Code::Unknown, "SQL execution not implemented"};
    }

    // ===== Schema Loading =====

    void loadSchemas() {
        // For now, hardcode User schema
        // TODO: Load from YAML files in /dbal/shared/api/schema/entities/
        EntitySchema userSchema;
        userSchema.name = "User";
        userSchema.displayName = "User";

        userSchema.fields = {
            {"id", "string", true, true, std::nullopt, std::nullopt},
            {"username", "string", true, true, std::nullopt, std::nullopt},
            {"email", "string", true, true, std::nullopt, std::nullopt},
            {"role", "string", true, false, "user", std::nullopt},
            {"profilePicture", "string", false, false, std::nullopt, std::nullopt},
            {"bio", "string", false, false, std::nullopt, std::nullopt},
            {"createdAt", "bigint", true, false, std::nullopt, std::nullopt},
            {"tenantId", "string", false, false, std::nullopt, std::nullopt},
            {"isInstanceOwner", "boolean", true, false, "false", std::nullopt},
            {"passwordChangeTimestamp", "bigint", false, false, std::nullopt, std::nullopt},
            {"firstLogin", "boolean", true, false, "false", std::nullopt}
        };

        schemas_["User"] = userSchema;
        schemas_["user"] = userSchema; // Allow lowercase
    }

    void createTables() {
        using namespace dbal::config;

        auto conn = pool_.acquire();
        if (!conn) {
            throw std::runtime_error("Unable to acquire SQL connection for table creation");
        }
        ConnectionGuard guard(pool_, conn);

        // Load all entity definitions from YAML - paths from environment variables
        std::string schema_dir = EnvConfig::getSchemaDir();
        spdlog::info("Loading schemas from: {}", schema_dir);
        auto entities = SchemaLoader::loadFromDirectory(schema_dir);
        spdlog::info("Loaded {} entity definitions", entities.size());

        // Create SQL template generator - template directory from environment
        std::string template_dir = EnvConfig::getTemplateDir();
        spdlog::info("Using templates from: {}", template_dir);
        SqlTemplateGenerator generator(template_dir);

        // Determine SQL dialect for template generation
        SqlDialect sql_dialect;
        if (dialect_ == Dialect::Postgres || dialect_ == Dialect::Prisma) {
            sql_dialect = SqlDialect::PostgreSQL;
        } else {
            sql_dialect = SqlDialect::MySQL;
        }

        // Generate and execute CREATE TABLE for each entity
        for (const auto& entity : entities) {
            // Generate CREATE TABLE SQL
            std::string create_sql = generator.generateCreateTable(entity, sql_dialect);

            // Execute CREATE TABLE
            try {
                executeNonQuery(conn, create_sql, {});
            } catch (const SqlError& err) {
                throw std::runtime_error("Failed to create table " + entity.name + ": " + err.message);
            }

            // Generate and execute CREATE INDEX statements
            auto index_statements = generator.generateIndexes(entity, sql_dialect);
            for (const auto& index_sql : index_statements) {
                try {
                    executeNonQuery(conn, index_sql, {});
                } catch (const SqlError&) {
                    // Index might already exist, ignore error
                }
            }
        }
    }

    std::optional<EntitySchema> getEntitySchemaInternal(const std::string& entityName) const {
        auto it = schemas_.find(entityName);
        if (it != schemas_.end()) {
            return it->second;
        }
        return std::nullopt;
    }

    // ===== SQL Building =====

    std::string buildInsertSql(const EntitySchema& schema, const Json& data) const {
        const std::string tableName = toLowerSnakeCase(schema.name);
        std::vector<std::string> fields;
        std::vector<std::string> placeholders;
        int paramIndex = 1;

        for (const auto& field : schema.fields) {
            if (field.name == "id" || field.name == "createdAt") {
                // Skip auto-generated fields
                continue;
            }
            if (data.contains(field.name)) {
                fields.push_back(field.name);
                placeholders.push_back(placeholder(paramIndex++));
            }
        }

        std::string sql = "INSERT INTO " + tableName + " (" + joinFragments(fields, ", ") + ") " +
                         "VALUES (" + joinFragments(placeholders, ", ") + ") " +
                         "RETURNING " + buildFieldList(schema);
        return sql;
    }

    std::string buildSelectSql(const EntitySchema& schema, const Json& filter) const {
        const std::string tableName = toLowerSnakeCase(schema.name);
        const std::string fieldList = buildFieldList(schema);
        std::string sql = "SELECT " + fieldList + " FROM " + tableName;

        if (!filter.empty()) {
            std::vector<std::string> whereFragments;
            int paramIndex = 1;
            for (const auto& [key, _] : filter.items()) {
                whereFragments.push_back(key + " = " + placeholder(paramIndex++));
            }
            sql += " WHERE " + joinFragments(whereFragments, " AND ");
        }

        return sql;
    }

    std::string buildUpdateSql(const EntitySchema& schema, const std::string& id, const Json& data) const {
        const std::string tableName = toLowerSnakeCase(schema.name);
        std::vector<std::string> setFragments;
        int paramIndex = 2; // 1 is for id

        for (const auto& field : schema.fields) {
            if (field.name == "id" || field.name == "createdAt") {
                continue; // Skip immutable fields
            }
            if (data.contains(field.name)) {
                setFragments.push_back(field.name + " = " + placeholder(paramIndex++));
            }
        }

        if (setFragments.empty()) {
            return "";
        }

        std::string sql = "UPDATE " + tableName + " SET " + joinFragments(setFragments, ", ") +
                         " WHERE id = " + placeholder(1) +
                         " RETURNING " + buildFieldList(schema);
        return sql;
    }

    std::string buildDeleteSql(const EntitySchema& schema, const std::string& id) const {
        const std::string tableName = toLowerSnakeCase(schema.name);
        return "DELETE FROM " + tableName + " WHERE id = " + placeholder(1);
    }

    std::string buildFieldList(const EntitySchema& schema) const {
        std::vector<std::string> fields;
        for (const auto& field : schema.fields) {
            fields.push_back(field.name);
        }
        return joinFragments(fields, ", ");
    }

    // ===== Data Conversion =====

    std::vector<SqlParam> jsonToParams(const EntitySchema& schema, const Json& data, const std::string& prependId = "") const {
        std::vector<SqlParam> params;

        if (!prependId.empty()) {
            params.push_back({"id", prependId});
        }

        for (const auto& field : schema.fields) {
            if (field.name == "id" || field.name == "createdAt") {
                continue; // Skip auto-generated
            }
            if (data.contains(field.name)) {
                params.push_back({field.name, jsonValueToString(data[field.name])});
            }
        }

        return params;
    }

    Json rowToJson(const EntitySchema& schema, const SqlRow& row) const {
        Json result;
        for (const auto& field : schema.fields) {
            const std::string value = columnValue(row, field.name);

            if (field.type == "boolean") {
                result[field.name] = (value == "1" || value == "true");
            } else if (field.type == "number" || field.type == "bigint") {
                if (!value.empty()) {
                    result[field.name] = std::stoll(value);
                } else {
                    result[field.name] = nullptr;
                }
            } else {
                if (value.empty() && !field.required) {
                    result[field.name] = nullptr;
                } else {
                    result[field.name] = value;
                }
            }
        }
        return result;
    }

    static std::string jsonValueToString(const Json& value) {
        if (value.is_null()) {
            return "";
        } else if (value.is_boolean()) {
            return value.get<bool>() ? "1" : "0";
        } else if (value.is_number()) {
            return std::to_string(value.get<int64_t>());
        } else if (value.is_string()) {
            return value.get<std::string>();
        } else {
            return value.dump();
        }
    }

    static std::string columnValue(const SqlRow& row, const std::string& key) {
        const auto itr = row.columns.find(key);
        return itr != row.columns.end() ? itr->second : "";
    }

    // ===== Utilities =====

    static Error mapSqlError(const SqlError& error) {
        switch (error.code) {
            case SqlError::Code::UniqueViolation:
                return Error::conflict(error.message);
            case SqlError::Code::ForeignKeyViolation:
                return Error::validationError(error.message);
            case SqlError::Code::NotFound:
                return Error::notFound(error.message);
            case SqlError::Code::Timeout:
            case SqlError::Code::ConnectionLost:
                return Error::internal(error.message);
            default:
                return Error::internal(error.message);
        }
    }

    static std::string joinFragments(const std::vector<std::string>& fragments, const std::string& separator) {
        std::ostringstream out;
        for (size_t i = 0; i < fragments.size(); ++i) {
            if (i > 0) {
                out << separator;
            }
            out << fragments[i];
        }
        return out.str();
    }

    static std::string toLowerSnakeCase(const std::string& pascalCase) {
        std::string result;
        for (size_t i = 0; i < pascalCase.size(); ++i) {
            char c = pascalCase[i];
            if (i > 0 && std::isupper(static_cast<unsigned char>(c))) {
                result += '_';
            }
            result += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        }
        return result;
    }

    std::string placeholder(size_t index) const {
        if (dialect_ == Dialect::Postgres || dialect_ == Dialect::Prisma) {
            return "$" + std::to_string(index);
        }
        return "?";
    }

    SqlPool pool_;
    Dialect dialect_;
    std::unordered_map<std::string, EntitySchema> schemas_;
};

// ===== Concrete Adapter Classes =====

class PostgresAdapter : public SqlAdapter {
public:
    explicit PostgresAdapter(const SqlConnectionConfig& config);
};

class MySQLAdapter : public SqlAdapter {
public:
    explicit MySQLAdapter(const SqlConnectionConfig& config);
};

class PrismaAdapter : public SqlAdapter {
public:
    explicit PrismaAdapter(const SqlConnectionConfig& config)
        : SqlAdapter(config, Dialect::Prisma) {}
};

class NativePrismaAdapter : public SqlAdapter {
public:
    explicit NativePrismaAdapter(const SqlConnectionConfig& config)
        : SqlAdapter(config, Dialect::Prisma),
          requestsClient_(resolveBridgeUrl(config), buildBridgeHeaders(resolveBridgeToken(config))) {}

    std::vector<SqlRow> runQuery(SqlConnection* connection,
                                 const std::string& sql,
                                 const std::vector<SqlParam>& params) override {
        (void)connection;
        const auto payload = buildPayload(sql, params, "query");
        const auto response = requestsClient_.post(
            "/api/native-prisma",
            payload.dump());
        if (response.statusCode != 200) {
            throw SqlError{SqlError::Code::Unknown, "Native Prisma bridge request failed"};
        }
        return parseQueryResponse(response.json);
    }

    int runNonQuery(SqlConnection* connection,
                    const std::string& sql,
                    const std::vector<SqlParam>& params) override {
        (void)connection;
        const auto payload = buildPayload(sql, params, "nonquery");
        const auto response = requestsClient_.post(
            "/api/native-prisma",
            payload.dump());
        if (response.statusCode != 200) {
            throw SqlError{SqlError::Code::Unknown, "Native Prisma bridge request failed"};
        }
        return parseNonQueryResponse(response.json);
    }

private:
    static std::string resolveBridgeUrl(const SqlConnectionConfig& config) {
        if (!config.prisma_bridge_url.empty()) {
            return config.prisma_bridge_url;
        }
        if (const char* env_url = std::getenv("DBAL_NATIVE_PRISMA_URL")) {
            return std::string(env_url);
        }
        return "http://localhost:3000";
    }

    static std::string resolveBridgeToken(const SqlConnectionConfig& config) {
        if (!config.prisma_bridge_token.empty()) {
            return config.prisma_bridge_token;
        }
        if (const char* env_token = std::getenv("DBAL_NATIVE_PRISMA_TOKEN")) {
            return std::string(env_token);
        }
        return "";
    }

    static std::unordered_map<std::string, std::string> buildBridgeHeaders(const std::string& token) {
        std::unordered_map<std::string, std::string> headers;
        headers["Content-Type"] = "application/json";
        if (!token.empty()) {
            headers["x-dbal-native-prisma-token"] = token;
        }
        return headers;
    }

    nlohmann::json buildPayload(const std::string& sql,
                                const std::vector<SqlParam>& params,
                                const std::string& type) const {
        nlohmann::json payload;
        payload["sql"] = sql;
        payload["type"] = type;
        payload["params"] = nlohmann::json::array();
        for (const auto& param : params) {
            payload["params"].push_back(param.value);
        }
        return payload;
    }

    std::vector<SqlRow> parseQueryResponse(const nlohmann::json& responseJson) const {
        std::vector<SqlRow> rows;
        if (responseJson.contains("rows") && responseJson["rows"].is_array()) {
            for (const auto& entry : responseJson["rows"]) {
                SqlRow row;
                if (entry.is_object()) {
                    for (const auto& [key, value] : entry.items()) {
                        if (value.is_string()) {
                            row.columns[key] = value.get<std::string>();
                        } else {
                            row.columns[key] = value.dump();
                        }
                    }
                }
                rows.push_back(std::move(row));
            }
        }
        return rows;
    }

    int parseNonQueryResponse(const nlohmann::json& responseJson) const {
        if (responseJson.contains("affected") && responseJson["affected"].is_number()) {
            return responseJson["affected"].get<int>();
        }
        return 0;
    }

    runtime::RequestsClient requestsClient_;
};

}
}
}

#endif
