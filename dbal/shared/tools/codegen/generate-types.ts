#!/usr/bin/env node
/**
 * DBAL Type Generator
 * 
 * Generates TypeScript type definitions from YAML entity schemas.
 * This ensures types are always in sync with the schema source of truth.
 */

import * as fs from 'fs'
import * as path from 'path'
import * as yaml from 'yaml'

interface YamlField {
  type: string
  primary?: boolean
  required?: boolean
  optional?: boolean
  nullable?: boolean
  generated?: boolean
  unique?: boolean
  sensitive?: boolean
  description?: string
  default?: unknown
  min_length?: number
  max_length?: number
  min?: number
  max?: number
  pattern?: string
  values?: string[]
  foreign_key?: {
    entity: string
    field: string
    on_delete?: string
  }
}

interface YamlEntity {
  entity: string
  version: string
  description?: string
  fields: Record<string, YamlField>
  indexes?: Array<{ fields: string[]; unique?: boolean }>
  acl?: Record<string, unknown>
  security?: Record<string, unknown>
}

/**
 * Maps YAML types to TypeScript types
 */
function mapYamlTypeToTS(yamlType: string): string {
  const typeMap: Record<string, string> = {
    uuid: 'string',
    string: 'string',
    text: 'string',
    email: 'string',
    integer: 'number',
    bigint: 'bigint',
    boolean: 'boolean',
    enum: 'string',
    json: 'unknown',
  }

  return typeMap[yamlType] || 'unknown'
}

/**
 * Generates a TypeScript interface for a YAML entity
 */
function generateEntityInterface(entity: YamlEntity): string {
  const interfaceName = entity.entity
  const fields: string[] = []

  // Add JSDoc comment
  let output = `/**\n * ${entity.description || entity.entity}\n`
  output += ` * @generated from ${entity.entity.toLowerCase()}.yaml\n */\n`

  for (const [fieldName, field] of Object.entries(entity.fields)) {
    const tsType = mapYamlTypeToTS(field.type)
    const isOptional = field.optional || field.nullable || !field.required
    const optionalMark = isOptional ? '?' : ''
    const nullableType = field.nullable ? ` | null` : ''

    // Add field comment if description exists or if sensitive
    if (field.description || field.sensitive) {
      const comment = field.description || ''
      const sensitiveNote = field.sensitive ? ' ‚ö†Ô∏è SENSITIVE - Never expose to client' : ''
      fields.push(`  /** ${comment}${sensitiveNote} */`)
    }

    fields.push(`  ${fieldName}${optionalMark}: ${tsType}${nullableType}`)
  }

  output += `export interface ${interfaceName} {\n`
  // Add index signature for compatibility with Record<string, unknown>
  output += '  [key: string]: unknown\n'
  output += fields.join('\n')
  output += '\n}\n'

  return output
}

/**
 * Scans all YAML entity files and generates types
 */
function generateAllTypes(): string {
  const schemaDir = path.resolve(__dirname, '../../api/schema/entities')
  const entities: YamlEntity[] = []

  // Recursively find all YAML files
  function findYamlFiles(dir: string): string[] {
    const results: string[] = []
    const items = fs.readdirSync(dir)

    for (const item of items) {
      const fullPath = path.join(dir, item)
      const stat = fs.statSync(fullPath)

      if (stat.isDirectory()) {
        results.push(...findYamlFiles(fullPath))
      } else if (item.endsWith('.yaml') || item.endsWith('.yml')) {
        results.push(fullPath)
      }
    }

    return results
  }

  const yamlFiles = findYamlFiles(schemaDir)

  // Parse all YAML files
  for (const file of yamlFiles) {
    try {
      const content = fs.readFileSync(file, 'utf-8')
      
      // Check if file contains multiple documents (separated by ---)
      // Match document separator: --- on its own line
      if (/(?:^|\n)---\s*(?:\n|$)/.test(content)) {
        // Parse all documents in the file
        const docs = yaml.parseAllDocuments(content)
        for (const doc of docs) {
          const parsed = doc.toJSON() as YamlEntity
          if (parsed && parsed.entity && parsed.fields) {
            entities.push(parsed)
          }
        }
      } else {
        // Single document
        const parsed = yaml.parse(content) as YamlEntity
        if (parsed && parsed.entity && parsed.fields) {
          entities.push(parsed)
        }
      }
    } catch (error) {
      console.error(`Error parsing ${file}:`, error)
    }
  }

  // Sort entities alphabetically for consistent output
  entities.sort((a, b) => a.entity.localeCompare(b.entity))

  // Generate output
  let output = `/**
 * DBAL Generated Types
 * 
 * DO NOT EDIT THIS FILE MANUALLY!
 * Generated from YAML entity schemas.
 * 
 * To regenerate: npm run dbal:generate-types
 */

`

  for (const entity of entities) {
    output += generateEntityInterface(entity)
    output += '\n'
  }

  return output
}

/**
 * Main execution
 */
function main() {
  try {
    console.log('üîß Generating TypeScript types from YAML schemas...')
    
    const output = generateAllTypes()
    const outputPath = path.resolve(
      __dirname,
      '../../..',
      'development/src/core/foundation/types/types.generated.ts'
    )

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    fs.writeFileSync(outputPath, output, 'utf-8')
    
    console.log(`‚úÖ Successfully generated types at: ${outputPath}`)
    console.log(`   Generated ${output.split('export interface').length - 1} entity types`)
  } catch (error) {
    console.error('‚ùå Error generating types:', error)
    process.exit(1)
  }
}

// Run if executed directly
if (require.main === module) {
  main()
}

export { generateAllTypes, generateEntityInterface, mapYamlTypeToTS }
