#!/usr/bin/env node
/**
 * DBAL Type Generator
 * 
 * Generates TypeScript type definitions from YAML entity schemas.
 * This ensures types are always in sync with the schema source of truth.
 */

const fs = require('fs')
const path = require('path')

// Simple YAML parser (supports subset needed for entity schemas)
function parseYAML(content) {
  const lines = content.split('\n')
  const result = {}
  const stack = [{ obj: result, indent: -1 }]
  let currentKey = null
  let currentIndent = 0

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const trimmed = line.trim()
    
    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) continue

    // Calculate indentation
    const indent = line.search(/\S/)
    
    // Pop stack if indent decreased
    while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
      stack.pop()
    }

    const current = stack[stack.length - 1].obj

    // Parse key-value
    if (line.includes(':')) {
      const colonIndex = line.indexOf(':')
      const key = line.substring(0, colonIndex).trim()
      const value = line.substring(colonIndex + 1).trim()

      if (value === '') {
        // Object key
        current[key] = {}
        stack.push({ obj: current[key], indent })
      } else if (value.startsWith('[') && value.endsWith(']')) {
        // Array value
        current[key] = value
          .substring(1, value.length - 1)
          .split(',')
          .map(v => v.trim())
          .filter(v => v)
      } else if (value === 'true' || value === 'false') {
        // Boolean
        current[key] = value === 'true'
      } else if (!isNaN(value) && value !== '') {
        // Number
        current[key] = Number(value)
      } else {
        // String (remove quotes if present)
        current[key] = value.replace(/^["']|["']$/g, '')
      }
    }
  }

  return result
}

/**
 * Maps YAML types to TypeScript types
 */
function mapYamlTypeToTS(yamlType) {
  const typeMap = {
    uuid: 'string',
    string: 'string',
    text: 'string',
    email: 'string',
    integer: 'number',
    bigint: 'bigint',
    boolean: 'boolean',
    enum: 'string',
    json: 'unknown',
  }

  return typeMap[yamlType] || 'unknown'
}

/**
 * Generates a TypeScript interface for a YAML entity
 */
function generateEntityInterface(entity) {
  const interfaceName = entity.entity
  const fields = []

  // Add JSDoc comment
  let output = `/**\n * ${entity.description || entity.entity}\n`
  output += ` * @generated from ${entity.entity.toLowerCase()}.yaml\n */\n`

  for (const [fieldName, field] of Object.entries(entity.fields)) {
    const tsType = mapYamlTypeToTS(field.type)
    const isOptional = field.optional || field.nullable || !field.required
    const optionalMark = isOptional ? '?' : ''
    const nullableType = field.nullable ? ` | null` : ''

    // Add field comment if description exists
    let comment = field.description || ''
    if (field.sensitive) {
      comment = comment ? `${comment} (sensitive - should not be sent to client)` : '(sensitive - should not be sent to client)'
    }
    if (comment) {
      fields.push(`  /** ${comment} */`)
    }

    fields.push(`  ${fieldName}${optionalMark}: ${tsType}${nullableType}`)
  }

  output += `export interface ${interfaceName} {\n`
  output += fields.join('\n')
  output += '\n  [key: string]: unknown  // Allow additional properties for DBAL compatibility\n'
  output += '}\n'

  return output
}

/**
 * Scans all YAML entity files and generates types
 */
function generateAllTypes() {
  const schemaDir = path.resolve(__dirname, '../../api/schema/entities')
  const entities = []

  // Recursively find all YAML files
  function findYamlFiles(dir) {
    const results = []
    const items = fs.readdirSync(dir)

    for (const item of items) {
      const fullPath = path.join(dir, item)
      const stat = fs.statSync(fullPath)

      if (stat.isDirectory()) {
        results.push(...findYamlFiles(fullPath))
      } else if (item.endsWith('.yaml') || item.endsWith('.yml')) {
        results.push(fullPath)
      }
    }

    return results
  }

  const yamlFiles = findYamlFiles(schemaDir)

  // Parse all YAML files
  for (const file of yamlFiles) {
    try {
      const content = fs.readFileSync(file, 'utf-8')
      const parsed = parseYAML(content)
      
      if (parsed.entity && parsed.fields) {
        entities.push(parsed)
      }
    } catch (error) {
      console.error(`Error parsing ${file}:`, error)
    }
  }

  // Sort entities alphabetically for consistent output
  entities.sort((a, b) => a.entity.localeCompare(b.entity))

  // Generate output
  let output = `/**
 * DBAL Generated Types
 * 
 * DO NOT EDIT THIS FILE MANUALLY!
 * Generated from YAML entity schemas.
 * 
 * To regenerate: npm run dbal:generate-types
 */

`

  for (const entity of entities) {
    output += generateEntityInterface(entity)
    output += '\n'
  }

  return output
}

/**
 * Main execution
 */
function main() {
  try {
    console.log('üîß Generating TypeScript types from YAML schemas...')
    
    const output = generateAllTypes()
    const outputPath = path.resolve(
      __dirname,
      '../../..',
      'development/src/core/foundation/types/types.generated.ts'
    )

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    fs.writeFileSync(outputPath, output, 'utf-8')
    
    console.log(`‚úÖ Successfully generated types at: ${outputPath}`)
    console.log(`   Generated ${output.split('export interface').length - 1} entity types`)
  } catch (error) {
    console.error('‚ùå Error generating types:', error)
    process.exit(1)
  }
}

// Run if executed directly
if (require.main === module) {
  main()
}

module.exports = { generateAllTypes, generateEntityInterface, mapYamlTypeToTS }
